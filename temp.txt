/*
 * File: main.c
 * Author: Diogo Gaspar, 99207, LEIC-A
 * Description: Main program file
 */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include "util.h"

/* main program function */
int main(){
	char command;
	start();
	do{
		printf("%c\n", command);
		command = getchar();
		redirectCommand(command);
	}while(!state);
	return 0;
}

/* adds a task to the system - 't' command */
void addTask(){
	int pd = 0; 
	char c, temp[MAX_TASKL] = {'\0'};
	
	scanf("%d", &pd); /* reading the predicted duration */
	c = readTaskAtv(temp, MAX_TASKL); /* reading description */
	skipLine(c);
	if(amTasks == MAX_TASK){ /* the system cannot accept more tasks */
    	printf(T_TOOMANY);
		return;
	}
	else if(dupSearch(TASK, temp)){ /* if it already exists */
		printf(T_EXISTS);
		return;
	}
	else if(pd <= 0){ /* if the duration is a negative integer */
		printf(INV_DUR);
		return;
	}

	updateTaskVec(temp, pd); 
	return;
}

/* adds a user to the system/lists all users by creation date - 'u' command */
void addUser(){
	int j;
    char c, temp[MAX_USERL] = {'\0'};
	
	c = readUser(temp, MAX_USERL); /* reading description */
	skipLine(c);
    if(dupSearch(USER, temp)){ /* if it already exists */
        printf(U_EXISTS);
    }
	else if(amUsers == MAX_USER && strcmp(temp, "")){ /* if the system can't accept more users */
		printf(U_TOOMANY);
	}
	else if(strcmp(temp, "")){ /* if the system is adding a user */
    	strcpy(userProp[amUsers++].desc, temp);
 	}
	else{ /* if the request is to print all usernames */
		for(j = 0; j < amUsers; j++){
			printf("%s\n", userProp[j].desc);
		}
	}
	return;
}

/* adds an activity to the system/lists all activities - 'a' command */
void addActivity(){
	int j;
    char c, temp[MAX_ATVL] = {'\0'};

	c = readTaskAtv(temp, MAX_ATVL);
	skipLine(c);
    if(findErrorAddAtv(temp) == FAIL){
		return;
	}
	else if(strcmp(temp, "")){ 
    	strcpy(atvProp[amAtvs++].desc, temp); /* add activity */
    }
    else{ 
    	for(j = 0; j < amAtvs; j++){ /* list all activities */ 
        	printf("%s\n", atvProp[j].desc);
        }
    }
	return;
}

/* advances the system's time - 'n' command*/
void advance(){
	int time;
	scanf("%d", &time);
	if(time < 0){
		printf(TIME_INVALID);
		return;
	}
	currentTime += time;
	printf("%d\n", currentTime);
	return;
}

/* lists all the tasks/a subset of tasks in the system - 'l' command */
void listTasks(){
	int idTemp, idCount = 0, error = 0, any;
	char c = getchar();
	while(COND(c)){
		scanf("%d", &idTemp);
		any = anyId(idTemp, amTasks, taskProp);
		if(any == FAIL){ /* if the ID is not in the system */
			printf(T_NOID, idTemp);
			error++;
		}
		else{
			/* prints the input's information if it was valid*/
			printf("%d %s #%d %s\n", taskProp[any].id, taskProp[any].currAtv, \
					taskProp[any].pd, taskProp[any].desc);
			idCount++;
		}
		c = getchar();
	}
	skipLine(c);
	if(idCount > 0 || (idCount == 0 && error > 0)){
		return;
	}
	else{ /*if the input was literally 'l' */
		shellDesc(taskProp, amTasks);
		printList(taskProp, amTasks, LT);
	}
	return;
}

/* prints the tasks currently in a given activity's scope - 'd' command */
void listAtvTasks(){
	int j = 0, index = 0, found = 0;
	char c, activity[MAX_ATVL] = {'\0'};
	task atvTasks[MAX_TASK] = {0};
	atv wantedAtv;

	c = readTaskAtv(activity, MAX_ATVL);
	skipLine(c);
	/* checks if the activity is in the system */
	for(j = 0; j < amAtvs && found == 0; j++){ 
		if(!strcmp(atvProp[j].desc, activity)){ /* if it is */
			found++;
			wantedAtv = atvProp[j];
		}
	}
	if(!found){ /* if the activity isn't in the system */
		printf(A_NOTFOUND);
		return;
	}
	/* stores the tasks in the activity's scope in a to-be-sorted array */
	for(j = 0; j < amTasks; j++){
		if(!strcmp(taskProp[j].currAtv, wantedAtv.desc)){
			atvTasks[index++] = taskProp[j];
		}
	}
	shellSt(atvTasks, wantedAtv.noTasks);
	printList(atvTasks, wantedAtv.noTasks, LAT);
	return;
}

/* moves a Task from an activity to the other; 'm' command */
void moveTasks(){
	int idTemp, afterAtv, beforeAtv, afterTask, wrongUser = 0, wrongAtv = 0;
	char c, username[MAX_USERL] = {'\0'}, afterDesc[MAX_ATVL] = {'\0'}, temp[MAX_ATVL] = {'\0'};
	
	scanf("%d", &idTemp);
	c = readUser(username, MAX_USERL);
	c = readTaskAtv(afterDesc, MAX_ATVL);
	skipLine(c);
	wrongUser = dupSearch(USER, username); /*check if username is in the system */
	wrongAtv = dupSearch(ATV, afterDesc); /*check if afterDesc is in the system */
	afterTask = findIndexTask(taskProp, idTemp);
	strcpy(temp, taskProp[afterTask].currAtv);
	if(printErrorsMove(idTemp, temp, afterDesc, wrongUser, wrongAtv)){
		return; /* returns to main if there were any errors found */
	}
	beforeAtv = findIndexAtv(atvProp, temp);
	afterAtv = findIndexAtv(atvProp, afterDesc);
	update_printMove(beforeAtv, afterAtv, afterTask, temp, afterDesc);
	return;
}

/* ------------------------------AUX FUNCTIONS------------------------------ */

/* starts the 3 "default" activities */
void start(){
	/* starting the 3 initial activities */
	strcpy(atvProp[TODO].desc, S_TODO);
	atvProp[TODO].noTasks = 0;
	strcpy(atvProp[INPROGRESS].desc, S_INPROGRESS);
	atvProp[INPROGRESS].noTasks = 0;
	strcpy(atvProp[DONE].desc, S_DONE);
	atvProp[DONE].noTasks = 0;
	amAtvs += 3; /* activity count after adding the 3 atvs above*/
	return;
}

/* redirects the program to a specific function, depending on the command */
void redirectCommand(char c){
	switch(c){ /* we know the command character is always the first */
		case 'q':
			state++;
			break;
		case 't':
			addTask();
			break;
		case 'l':
			listTasks();
			break;
		case 'n':
			advance();
			break;
		case 'u':
			addUser();
			break;
		case 'm':
			moveTasks();
			break;
		case 'd':
			listAtvTasks();
			break;
		case 'a':
			addActivity(); /* default not needed, command always right */
	}
	return;
}

/* FAIL if the ID isn't in the system; its index in the tasks array if it is */
int anyId(int n, int size, task v[]){
	int i, res = FAIL;
	for(i = 0; i < size; i++){
		if(v[i].id == n){
			res = i;
		}
	}
	return res;
}

/* reads a portion of a string and returns the first integer found*/
int readNumber(){
	int reading = 0, res = FAIL; 
	int menos = 0;
	char c = getchar();
	while(reading == 0 || !isspace(c)){
		if(reading == 0 && !isspace(c)){ /* the input will now be read */
			res = 0;
			reading = 1;
		}
		if(isdigit((int) c)){
		 	res = res * 10 + (c - '0');
		}
		else if(c == '-'){
			menos = 1;
		}
		c = getchar();
	}
	if(menos == 1 && res != FAIL){
		res = -res;
	}
	return res;
}

/* reads a portion of a string and stores the description in s */
char readTaskAtv(char *s, int max){ 
	int index = 0, reading = 0;
	char c = getchar();
	while(COND(c) && index < max - 1){
		if (!reading && !isspace(c)){
			reading++;
		}
		if(reading){
			s[index++] = c;
		}
		c = getchar();
	}
	s[index] = '\0';
	return c;
}

/* reads a portion of a string and stores the username in s */
char readUser(char *s, int max){
	int index = 0, reading = 0;
	char c = getchar();
	while(COND(c) && index < max - 1){
		if(reading == 0 && !isspace(c)){
			reading++;
		}
		if(reading){
			if(isspace(c)){
				return c;
			}
			else{
				s[index++] = c;
			}
		}
		c = getchar();
	}
	s[index] = '\0';
	return c;
}

/* used in listTasks/listAtvTasks to print the tasks' information */
void printList(task v[], int n, int func){
	int i;
	switch(func){
		case LT:
			for(i = 0; i < n; i++){
				printf("%d %s #%d %s\n", v[i].id, v[i].currAtv, v[i].pd, v[i].desc);
			}
			break;
		case LAT:
			for(i = 0; i < n; i++){
				printf("%d %d %s\n", v[i].id, v[i].st, v[i].desc);
			}
			break;
		default:
			break;
	}
	return;
}

/* checks if a given description already exists in the system */
int dupSearch(char mode, char s[]){
	int i, dup = 0;
	switch(mode){
		case TASK: /* comparing task descriptions */
			for(i = 0; i < amTasks && dup == 0; i++){
				if(!strcmp(s, taskProp[i].desc)) 
					dup++;
			}
			break;
		case USER: /* comparing user descriptions */
			for(i = 0; i < amUsers && dup == 0; i++){
				if(!strcmp(s, userProp[i].desc)) 
					dup++;
			}
			break;
		case ATV: /* comparing activity descriptions */
			for(i = 0; i < amAtvs && dup == 0; i++){
				if(!strcmp(s, atvProp[i].desc)) 
					dup++;
			}
			break; /* no need for a default case here */
	}
	return dup;
}

/* sorts a given array of tasks following the 'l' command rules */
void shellDesc(task v[], int cap){
	int i, sep, j;
	task tempTask;
	for(sep = cap/2; sep > 0; sep /= 2){
		for(i = sep; i < cap; i++){
			tempTask = v[i];
			for(j = i; j >= sep && strcmp(tempTask.desc, v[j - sep].desc) < 0; j-= sep){
				v[j] = v[j - sep];
			}
			v[j] = tempTask;
		}
	}
	return;
}

/* sorts a given array of tasks following the 'd' command rules */
void shellSt(task v[], int cap){
	int i, sep, j, stop = 0;
	task tempTask;
	for(sep = cap/2; sep > 0; sep /= 2){
		for(i = sep; i < cap; i++){
			for(j = i - sep; j >= 0 && stop == 0; j -= sep){
				if(v[j + sep].st > v[j].st){
					stop = 1;
				}
				else if((v[j + sep].st < v[j].st) ||
						(v[j + sep].st == v[j].st &&
						strcmp(v[j + sep].desc, v[j].desc) < 0)){
					tempTask = v[j];
					v[j] = v[j + sep];
					v[j + sep] = tempTask;
				}
			}
			stop = 0;
		}
	}
	return;
}

/* aux to moveTasks, prints some of the possible error messages */
int printErrorsMove(int id, char befDesc[], char atvDesc[], int wUser, int wAtv){
	int error = 0;
	if(anyId(id, amTasks, taskProp) == FAIL){ 
		printf(NO_ID_M); /* if the ID isn't in the system */
		error ++;
	}
	else if(!strcmp(atvDesc, S_TODO) && !strcmp(befDesc, S_TODO)){
		error++; /* the program still stops if both befDesc and aDesc are S_TODO */
	}
	else if(!strcmp(atvDesc, S_TODO) && strcmp(befDesc, S_TODO)){
		printf(T_STARTED); /* if the "going to" activity is TO DO */
		error++;
	}
	else if(wUser == ZERO){
		printf(U_NOTFOUND); /* if the username is not in the system */
		error++;
	}
	else if(wAtv == ZERO){
		printf(A_NOTFOUND); /* if the activity is not in the system */
		error++;
	}
	return error;
}

/* returns the index in taskProp of the task with the given ID */
int findIndexTask(task v[], int idTemp){
	int i, res = 0, found = 0;
	for(i = 0; i < amTasks && !found; i++){
		if(v[i].id == idTemp){
			res = i;
			found++;
		}
	}
	return res;
}

/* returns the index in atvProp of the activity with the given description */
int findIndexAtv(atv v[], char description[]){
	int i, res = 0, found = 0;
	for(i = 0; i < amAtvs && !found; i++){
		if(!strcmp(description, v[i].desc)){
			res = i;
			found++;
		}
	}
	return res;
}

/* updates and print (if applicable) information regarding atvs/tasks involved in moveTasks */
void update_printMove(int beforeIndex, int afterIndex, int afterT, char beforeA[], char afterA[]){
	/* adjusts the number of tasks in the activities found above */	
	atvProp[beforeIndex].noTasks--;
	atvProp[afterIndex].noTasks++;
	strcpy(taskProp[afterT].currAtv, afterA);

	/* if the "activity being left" is TO DO, the starting time is adjusted */
	if(!strcmp(beforeA, S_TODO)){
		taskProp[afterT].st = currentTime;		
	}
	else{ /* else, the duration is adjusted */
		taskProp[afterT].duration = currentTime - taskProp[afterT].st;
	}

	taskProp[afterT].slack = taskProp[afterT].duration - taskProp[afterT].pd;

	/* only prints if the "activity being left" is not DONE and the "going to" is */
	if(!strcmp(afterA, S_DONE) && strcmp(beforeA, S_DONE)){
		printf(DURSLACK, taskProp[afterT].duration, taskProp[afterT].slack);
	}
	return;
}

/* updates and prints messages related to the addTask function */
void updateTaskVec(char desc[], int pd){
	strcpy(taskProp[amTasks].desc, desc);
	taskProp[amTasks].pd = pd;
	taskProp[amTasks].st = 0;
	taskProp[amTasks].duration = 0;
	taskProp[amTasks].id = amTasks + 1;

	strcpy(taskProp[amTasks].currAtv, S_TODO);
	atvProp[TODO].noTasks++;

	printf(T_WRITEID, taskProp[amTasks++].id);
	return;
}

/* finds (and prints) errors in addActivity */
int findErrorAddAtv(char desc[]){
	int j;
	for(j = 0; j < amAtvs; j++){
    	if (!strcmp(desc, atvProp[j].desc)){
        	printf(A_EXISTS); /* if the description is in the system */
			return FAIL;
        }
    }
    for(j = 0; j < (int) strlen(desc); j++){ 
		if(islower(desc[j])){
			printf(A_INVALID); /*if a lowercase char is found */
			return FAIL;
		}
	}

    if(amAtvs == MAX_ATV && strcmp(desc, "")){ 
    	printf(A_TOOMANY); /* if the system can't accept more atvs */
		return FAIL;
    }
	return ZERO;
}

/* skips to the next line, ignoring the current line's remaining content */
void skipLine(char c){
	while(COND(c)){
		c = getchar();
	}
	return;
}